<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ç°¡æ˜“ä¹—æ›æ¡ˆå†…</title>
  <script src="https://cdn.tailwindcss.com"></script>
</head>
<body class="bg-gray-50 p-8">
  <div class="max-w-4xl mx-auto">
    <h1 class="text-3xl font-bold text-center mb-8 text-blue-600">ğŸš‡ ç°¡æ˜“ä¹—æ›æ¡ˆå†…</h1>
    
    <div class="bg-white rounded-lg shadow-md p-6 mb-6">
      <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
        <div>
          <label class="block text-sm font-medium text-gray-700 mb-2">å‡ºç™ºé§…</label>
          <select id="departure" class="w-full p-2 border border-gray-300 rounded-md">
            <option value="">é§…ã‚’é¸æŠã—ã¦ãã ã•ã„</option>
          </select>
        </div>
        <div>
          <label class="block text-sm font-medium text-gray-700 mb-2">åˆ°ç€é§…</label>
          <select id="arrival" class="w-full p-2 border border-gray-300 rounded-md">
            <option value="">é§…ã‚’é¸æŠã—ã¦ãã ã•ã„</option>
          </select>
        </div>
      </div>
      
      <button onclick="searchRoute()" class="w-full bg-blue-600 text-white py-3 rounded-md hover:bg-blue-700 transition">
        çµŒè·¯ã‚’æ¤œç´¢
      </button>
    </div>

    <div id="result" class="space-y-4"></div>
  </div>

  <!-- å¤–éƒ¨JSãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã¿è¾¼ã¿ -->
  <script src="routeData.js"></script>
  <script src="fareRates.js"></script>
  <script src="transferData.js"></script>
  <script src="campusData.js"></script>
  
  <!-- ãƒ¡ã‚¤ãƒ³ã‚¹ã‚¯ãƒªãƒ—ãƒˆ -->
  <script>
    // å…¨é§…ãƒªã‚¹ãƒˆã‚’ç”Ÿæˆ
    function getAllStations() {
      const stations = new Set();
      Object.values(routeData).forEach(line => {
        line.forEach(segment => {
          stations.add(segment.from);
          stations.add(segment.to);
        });
      });
      return Array.from(stations).sort();
    }

    // é§…é¸æŠãƒ‰ãƒ­ãƒƒãƒ—ãƒ€ã‚¦ãƒ³ã‚’åˆæœŸåŒ–
    function initializeStationSelects() {
      const stations = getAllStations();
      const departureSelect = document.getElementById('departure');
      const arrivalSelect = document.getElementById('arrival');
      
      stations.forEach(station => {
        departureSelect.add(new Option(station, station));
        arrivalSelect.add(new Option(station, station));
      });
    }

    // è·¯ç·šã‚°ãƒ©ãƒ•ã‚’æ§‹ç¯‰
    function buildGraph() {
      const graph = {};
      
      Object.entries(routeData).forEach(([lineName, segments]) => {
        segments.forEach(segment => {
          // é †æ–¹å‘
          if (!graph[segment.from]) graph[segment.from] = [];
          graph[segment.from].push({
            station: segment.to,
            line: lineName,
            time: segment.trains ? Math.min(...segment.trains.map(t => t.time)) : segment.time,
            distance: segment.distance,
            segmentData: segment
          });
          
          // é€†æ–¹å‘
          if (!graph[segment.to]) graph[segment.to] = [];
          graph[segment.to].push({
            station: segment.from,
            line: lineName,
            time: segment.trains ? Math.min(...segment.trains.map(t => t.time)) : segment.time,
            distance: segment.distance,
            segmentData: segment
          });
        });
      });
      
      return graph;
    }

    // ãƒ€ã‚¤ã‚¯ã‚¹ãƒˆãƒ©æ³•ã§æœ€çŸ­çµŒè·¯ã‚’æ¢ç´¢
    function findRoute(start, end, mode = 'time') {
      const graph = buildGraph();
      const distances = {};
      const previous = {};
      const segments = {};
      const unvisited = new Set(Object.keys(graph));
      
      Object.keys(graph).forEach(station => {
        distances[station] = Infinity;
      });
      distances[start] = 0;
      
      while (unvisited.size > 0) {
        let current = null;
        let minDistance = Infinity;
        
        unvisited.forEach(station => {
          if (distances[station] < minDistance) {
            minDistance = distances[station];
            current = station;
          }
        });
        
        if (current === null || current === end) break;
        unvisited.delete(current);
        
        if (!graph[current]) continue;
        
        graph[current].forEach(edge => {
          if (!unvisited.has(edge.station)) return;
          
          let weight = mode === 'time' ? edge.time : edge.distance;
          
          // ä¹—æ›æ™‚é–“ã‚’åŠ ç®—
          if (previous[current] && segments[current]) {
            const prevLine = segments[current].line;
            if (prevLine !== edge.line) {
              const transferKey1 = `${prevLine} â‡” ${edge.line}`;
              const transferKey2 = `${edge.line} â‡” ${prevLine}`;
              const transferTime = transferData[current]?.[transferKey1] || 
                                   transferData[current]?.[transferKey2] || 5;
              weight += transferTime;
            }
          }
          
          const newDistance = distances[current] + weight;
          
          if (newDistance < distances[edge.station]) {
            distances[edge.station] = newDistance;
            previous[edge.station] = current;
            segments[edge.station] = edge;
          }
        });
      }
      
      // çµŒè·¯ã‚’å¾©å…ƒ
      if (distances[end] === Infinity) return null;
      
      const path = [];
      let current = end;
      
      while (current !== start) {
        path.unshift(current);
        current = previous[current];
      }
      path.unshift(start);
      
      // è©³ç´°ãªçµŒè·¯æƒ…å ±ã‚’æ§‹ç¯‰
      const routeSegments = [];
      for (let i = 0; i < path.length - 1; i++) {
        const seg = segments[path[i + 1]];
        routeSegments.push(buildRouteSegment(seg.line, path[i], path[i + 1], seg.segmentData));
      }
      
      return {
        path: path,
        segments: routeSegments,
        totalTime: distances[end],
        totalDistance: routeSegments.reduce((sum, seg) => sum + seg.distance, 0)
      };
    }

    // çµŒè·¯æƒ…å ±ã‚’æ§‹ç¯‰
    function buildRouteSegment(line, fromStation, toStation, segmentData) {
      let time = segmentData.time;
      let trainInfo = "";
      
      if (segmentData.trains) {
        const fastestTrain = segmentData.trains.reduce((prev, current) => 
          prev.time < current.time ? prev : current
        );
        time = fastestTrain.time;
        
        if (segmentData.trains.length > 1) {
          const trainTypes = segmentData.trains.map(t => {
            if (t.extraFare) {
              return `${t.type}${t.time}åˆ†ï¼ˆåˆ¥é€”ç‰¹æ€¥æ–™é‡‘ï¼‰`;
            }
            return `${t.type}${t.time}åˆ†`;
          }).join('ãƒ»');
          trainInfo = ` [${trainTypes}]`;
        } else if (fastestTrain.type) {
          trainInfo = ` [${fastestTrain.type}]`;
        }
        
        if (fastestTrain.note) {
          trainInfo += ` â€»${fastestTrain.note}`;
        }
      }
      
      if (segmentData.note && !trainInfo.includes('â€»')) {
        trainInfo += ` â€»${segmentData.note}`;
      }
      
      return {
        line: line,
        from: fromStation,
        to: toStation,
        time: time,
        distance: segmentData.distance,
        trainInfo: trainInfo
      };
    }

    // é‹è³ƒã‚’è¨ˆç®—
    function calculateFare(segments) {
      const companyDistances = {};
      
      segments.forEach(seg => {
        const company = getCompany(seg.line);
        if (!companyDistances[company]) {
          companyDistances[company] = 0;
        }
        companyDistances[company] += seg.distance;
      });
      
      let totalFare = 0;
      Object.entries(companyDistances).forEach(([company, distance]) => {
        const rates = fareRates[company];
        if (!rates) return;
        
        for (let i = 0; i < rates.length; i++) {
          if (distance <= rates[i].max) {
            totalFare += rates[i].fare;
            break;
          }
        }
      });
      
      // ãƒ¡ãƒˆãƒ­â‡”éƒ½å–¶ã®ä¹—ç¶™å‰²å¼•
      if (companyDistances["æ±äº¬ãƒ¡ãƒˆãƒ­"] && 
          (companyDistances["éƒ½å–¶åœ°ä¸‹é‰„"] || companyDistances["éƒ½å–¶"])) {
        totalFare -= 70;
      }
      
      return totalFare;
    }

    // è·¯ç·šã‹ã‚‰é‰„é“ä¼šç¤¾ã‚’åˆ¤å®š
    function getCompany(line) {
      if (line.includes("æ±äº¬ãƒ¡ãƒˆãƒ­")) return "æ±äº¬ãƒ¡ãƒˆãƒ­";
      if (line.includes("éƒ½å–¶")) return "éƒ½å–¶åœ°ä¸‹é‰„";
      if (line.includes("JR")) return "JRæ±æ—¥æœ¬";
      if (line.includes("äº¬ç‹")) return "äº¬ç‹é›»é‰„";
      if (line.includes("å°ç”°æ€¥")) return "å°ç”°æ€¥é›»é‰„";
      if (line.includes("æ±æ€¥")) return "æ±æ€¥é›»é‰„";
      if (line.includes("è¥¿æ­¦")) return "è¥¿æ­¦é‰„é“";
      if (line.includes("æ±æ­¦")) return "æ±æ­¦é‰„é“";
      if (line.includes("å¤šæ‘©ãƒ¢ãƒãƒ¬ãƒ¼ãƒ«")) return "å¤šæ‘©éƒ½å¸‚ãƒ¢ãƒãƒ¬ãƒ¼ãƒ«";
      if (line.includes("ã¤ãã°ã‚¨ã‚¯ã‚¹ãƒ—ãƒ¬ã‚¹")) return "ã¤ãã°ã‚¨ã‚¯ã‚¹ãƒ—ãƒ¬ã‚¹";
      return "ãã®ä»–";
    }

    // æ¤œç´¢å®Ÿè¡Œ
    function searchRoute() {
      const departure = document.getElementById('departure').value;
      const arrival = document.getElementById('arrival').value;
      
      if (!departure || !arrival) {
        alert('å‡ºç™ºé§…ã¨åˆ°ç€é§…ã‚’é¸æŠã—ã¦ãã ã•ã„');
        return;
      }
      
      if (departure === arrival) {
        alert('å‡ºç™ºé§…ã¨åˆ°ç€é§…ãŒåŒã˜ã§ã™');
        return;
      }
      
      const resultDiv = document.getElementById('result');
      resultDiv.innerHTML = '<div class="text-center text-gray-600">æ¤œç´¢ä¸­...</div>';
      
      setTimeout(() => {
        const fastestRoute = findRoute(departure, arrival, 'time');
        
        if (!fastestRoute) {
          resultDiv.innerHTML = '<div class="bg-red-50 border border-red-200 rounded-lg p-4 text-red-700">çµŒè·¯ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸ</div>';
          return;
        }
        
        displayRoute(fastestRoute, 'æœ€é€Ÿãƒ«ãƒ¼ãƒˆ');
      }, 100);
    }

    // çµŒè·¯ã‚’è¡¨ç¤º
    function displayRoute(route, title) {
      const resultDiv = document.getElementById('result');
      const fare = calculateFare(route.segments);
      const transfers = countTransfers(route.segments);
      
      let html = `
        <div class="bg-white rounded-lg shadow-md p-6">
          <h2 class="text-xl font-bold text-blue-600 mb-4">${title}</h2>
          <div class="grid grid-cols-3 gap-4 mb-4 text-center">
            <div>
              <div class="text-2xl font-bold text-blue-600">${Math.round(route.totalTime)}åˆ†</div>
              <div class="text-sm text-gray-600">æ‰€è¦æ™‚é–“</div>
            </div>
            <div>
              <div class="text-2xl font-bold text-green-600">${fare}å††</div>
              <div class="text-sm text-gray-600">é‹è³ƒï¼ˆICï¼‰</div>
            </div>
            <div>
              <div class="text-2xl font-bold text-purple-600">${transfers}å›</div>
              <div class="text-sm text-gray-600">ä¹—æ›</div>
            </div>
          </div>
          <div class="border-t pt-4">
      `;
      
      route.segments.forEach((seg, idx) => {
        if (idx === 0 || seg.line !== route.segments[idx-1].line) {
          html += `<div class="text-sm font-semibold text-blue-600 mt-2">${seg.line}</div>`;
        }
        html += `<div class="text-sm ml-4">
          ${seg.from} â†’ ${seg.to} (${seg.time}åˆ†)${seg.trainInfo || ''}
        </div>`;
      });
      
      html += `</div></div>`;
      resultDiv.innerHTML = html;
    }

    // ä¹—æ›å›æ•°ã‚’ã‚«ã‚¦ãƒ³ãƒˆ
    function countTransfers(segments) {
      let count = 0;
      for (let i = 1; i < segments.length; i++) {
        if (segments[i].line !== segments[i-1].line) {
          count++;
        }
      }
      return count;
    }

    // åˆæœŸåŒ–
    window.addEventListener('DOMContentLoaded', () => {
      initializeStationSelects();
    });
  </script>
</body>
</html>
